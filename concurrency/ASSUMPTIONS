###### Print Assumptions:

After building the entire project (See README) you can print the
assumptions of our main theorem with:

	make assumptions-concurrency 

This will show all the Axioms, Assumptions and Admitted Lemmas used by
the main lemma in main.v. An explanation of these assumptions can be
found below, and a detailed explanation of each Admitted lemma can be
found as comments in its file.

If you want to see the assumptions without having to build the entire
project (or while the project builds), we have included a file
	concurrency/assumptions_output
With the current assumptions. The file should match the output of the
command above and can be updated by using:

	make assumptions-concurrency > concurrency/assumptions_output
	

To show not only the names, but the types, of all assumptions you
may also run:

	make assumptions-concurrency-body

This will show the same output above, but with the definition of each
assumption. For better formatting, you may also open the file
[main_print_assumptions.v] in CoqIDE or Proof General. The last
command will print the assumptions.



###### Explaining the assumptions: 
 The unproved axioms and assumptions fall into these categories:

------------ STANDARD AXIOMS OF LOGIC
1. Standard axioms, known to be consistent with Coq.
2. Two axioms of the real numbers, used by CompCert's floating point proofs.
------------ AXIOMS OF COMPCERT
3. CompCert linkage, forced upon us by the way CompCert axiomatizes external functions.
4. Properties that are true of CompCert but have not yet been exported
  by (standard) CompCert as axioms or theorems, because (before our work)
  there was not yet a need.
----------- PARTS OF OUR PROOF UNFINISHED IN COQ, "obviously" true
5. Self simulations, proved by other authors in similar settings.
6. Reestablishing concur_match, minor incomplete parts of our proof.
7. Simple (but tedious) properties of the CompCert operational semantics.
8. Simple (but tedious) property of the monotonicity of our juicy safety judgment. 
9. Two lemmas under construction.

#### 1. Standard axioms
  These are standard axioms known to be consistent with Coq (and with
   each other).
	
* Axioms.prop_ext:
	Propositional extensionality
* ProofIrrelevance.proof_irrelevance:
	Proof Irrelevance 
* lib.Axioms.proof_irr:
	Proof Irrelevance (2nd import)
* Eqdep.Eq_rect_eq.eq_rect_eq:
	invariance by substitution of reflexive equality proofs
* Classical_Prop.classic:
	Excluded middle.
* JMeq.JMeq_eq:
	John Major Equality.
* FunctionalExtensionality.functional_extensionality_dep 
	Dependent functional extensionality


#### 2. Real numbers  (needed only by CompCert's floating-point theory)

* ClassicalDedekindReals.sig_not_dec :
	Classical Dedekind reals.
* ClassicalDedekindReals.sig_forall_dec:
	Classical Dedekind reals.
	

#### 3. CompCert linkage:

The synchronization functions are in the context:
CompCert links with external-function semantics via a given "Parameter"
that gives their semantics. We must assume that our 
synchronization functions are part of that parameter.

* synchronisation_steps_semantics.sync_functions_are_in_context

Inlined assembly is well defined:
If the program contains any inlined assembly, CompCert 
requires the following two parameters.  These are axioms of CompCert,
not of our concurrency proofs, and we ourselves do not introduce any
inlined assembly code.

* Events.inline_assembly_sem:
	Parameter describing the behavior of inlined assembly.
* Events.inline_assembly_properties:
	Inlined assembly satisfies the same properties that 
	CompCert requires of external functions.
* Events.external_functions_sem:
	Semantics of external functions.
* Events.external_functions_properties:
	External functions satisfy the properties required by CompCert. 
	

#### 4. Properties of CompCert semantics:

* concurrent_compiler_safety_proof.Clight_finite_branching:
	The Clight semantics is finite branching. In other words, 
	every step can only step to a finite number of states.
* safety_equivalence.finite_state_preservation:
	A set of Clight states is finite branching. In other words,
	there is a finite number states that can be reached, by
	taking one single step, from a finite set of Clight states.
	This fact follows from the Clight_finite_branching above.
* Asm.get_arguments_correct:
	Correctness of the way CompCert gets arguments from stack.
	This is architecture dependent.

#### 5. Self simulations

   Self simulation, described in the paper in Definition 5.14, has been proven
before (about CompCert semantics) by several published works. Their semantics 
is slightly different than ours, so we can't directly reuse their proofs. 
Proving the following lemmas should be tedious but straightforward:

* CPM_self_simulation.thread_step_preserves_self_simulates 
	The CPM self-simulates
* CPM_self_simulation.self_simulates_initial:
	The CPM self-simulates, initial diagram
* CPM_self_simulation.self_simulates_match:
	The CPM self-simulates match is not yet defined.
* CPM_self_simulation.machine_step_preserves_self_simulates:
	The CPM self-simulates, diagram for machine steps  
* CPM_self_simulation.lift_self_simulates:
	Hybrid CPMs are equal if the number of threads is less than their bound.
* Clight_self_simulation.clight_self_simulation:
	The Clight language self-simulates
* Asm_self_simulation.Asm_self_simulation 
	The Asm language self-simulates
* concurrent_compiler_simulation_proof.trivial_asm_simulation 
	The Asm language self-simulates
	

#### 6. Reestablishing the concur_match:

In every step diagram for the CPM, we must reestablish the relation between the
resulting CPM steps. In all the lemmas, parts of the state change (e.g. the 
state of the running thread) and others don't (e.g. the state of other threads).
For the lemmas below, the NEW relationships have been established, but 
we still must recover the relationship of the parts of the state that have not 
changed. This is straightforward, but tedious.

* concur_match.concur_match_update_lock 
* concur_match.concur_match_updateC 
* concur_match.concur_match_updLock_empty 
* concur_match.concur_match_thread_step 
* concur_match.concur_match_free_lock 
* concur_match.concur_match_add_thread 


#### 7. External functions, built-ins and inlined assembly:

We have to impose certain limitations to external functions, 
built-ins and inlined assembly, presented here. We separate 
these restrictions in two lists: the ones that CompCert should
enforce and the ones that we enforce.

	## Compcert should enforce these properties:

* Clight_core.inline_external_call_mem_events:
	External functions that the compiler can inline 
	(which can be done for some built-ins), must respect
	the memory interface. 
* Clightcore_coop.inline_assembly_memstep:
	Inlined assembly should respect the memory interface.
* ClightSemanticsForMachines.Clight_step_nil_trace_not_atx:
	We assume externals, that are not built-ins, have
	no trace. This restriction can easily be lifted
	by distinguishing between synch calls and other
	external functions.
* Clight_mem_ok.external_call_wellformed:
	External calls must preserve well-formed memories. 
        That is, they don't introduce dangling pointers.

	## New properties we require:
* ClightSemanticsForMachines.extcall_ev_elim:
	Builtins respect the memory interface and form an
	"event" memory semantics.  The best way to handle this
	would be to change CompCert so that, in the Clight language,
	the current "builtins" are represented instead as
	"inlineable external calls", and then CompCert's phase
	that (currently) generates code for the builtins can instead
	inline the external calls.  The end result (generated code)
	would be identical, the Clight language would be simplified,
	and this assumption would be eliminated.

#### 8. Juicy Semantics:
	
* semax_safety_spawn.Concurrent_Espec_permits_framing:
	If a CompCert Clight program state with memory m is safe to
	(single-thread) execute, then it is safe in any memory m'
	whose permissions are greater than m.
	
#### 9. Lemmas under construction

For every thread, we preserve a relation between the allocated blocks in the two executions. Using these relations we can also show a relation between the acquired/released resources in the two executions. Similarly, we need to show that initial memories are related in the two executions, which should follow the same techniques as the cases for acquire/release. However, this relation has to be carried through one more step (while the thread is in Kinit) and we havenâ€™t proved that part.

* single_thread_simulation_proof.start_step_diagram:
	This lemma depends on two facts that are true but have not yet 
	been propagated through the other parts of the project. 
* compcert_threads_lemmas.SimProofs.sim_external 
	We had a working version of this proof until it broke after 
	some updates to VST. The authors will be working on fixing 
	these shortly.

